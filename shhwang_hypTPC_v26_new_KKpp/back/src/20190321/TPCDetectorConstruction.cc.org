// ====================================================================
//   TPCDetectorConstruction.cc
//
// ====================================================================
#include "TPCDetectorConstruction.hh"

#include "G4Element.hh"
#include "G4Material.hh"
#include "G4Box.hh"
#include "G4Tubs.hh"
#include "G4Trd.hh"
#include "G4Polyhedra.hh"
#include "G4LogicalVolume.hh"
#include "G4UnionSolid.hh"
#include "G4SubtractionSolid.hh"
#include "G4PVPlacement.hh"
#include "G4PVReplica.hh"
#include "G4VisAttributes.hh"
#include "G4SDManager.hh"

// For magnetic field
#include "G4FieldManager.hh"
#include "G4TransportationManager.hh"
#include "G4ChordFinder.hh"
#include "TPCField.hh"

// For Sensitive Detector
#include "TPCPadSD.hh"
#include "TPCScintSD.hh"



//////////////////////////////////////////////////
TPCDetectorConstruction::TPCDetectorConstruction()
//////////////////////////////////////////////////
{
}

///////////////////////////////////////////////////
TPCDetectorConstruction::~TPCDetectorConstruction()
///////////////////////////////////////////////////
{
}

/////////////////////////////////////////////////////////
G4VPhysicalVolume* TPCDetectorConstruction::Construct()
/////////////////////////////////////////////////////////
{
  // ==============================================================
  // elements
  // ==============================================================
  G4double A, Z;
  G4String name, symbol;
  const double inch = 2.54*cm;
  char name1[30],name2[30];
  char name11[30],name22[30];
  
  G4Colour aqua(0.247, 0.8, 1.0);
  G4Colour magenda(1.0, 0.0, 1.0);
  G4Colour yellow(1.0, 1.0, 0.0);


  A= 1.00794 *g/mole;
  G4Element* elH= new G4Element(name="Hydrogen", symbol="H", Z=1., A);

  A= 12.011 *g/mole;
  G4Element* elC= new G4Element(name="Carbon", symbol="C", Z=6., A);

  A= 14.00674 *g/mole;
  G4Element* elN= new G4Element(name="Nitrogen", symbol="N", Z=7., A);

  A= 15.9994 *g/mole;
  G4Element* elO= new G4Element(name="Oxygen", symbol="O", Z=8., A);

  A= 39.948 *g/mole;
  G4Element* elAr= new G4Element(name="Argon", symbol="Ar", Z=18., A);

  A= 28.0855 *g/mole;
  G4Element* elSi= new G4Element(name="Silicon", symbol="Si", Z=14., A);

  A= 126.90447 *g/mole;
  G4Element* elI= new G4Element(name="Iodine", symbol="I", Z=53., A);

  A= 132.90543 *g/mole;
  G4Element* elCs= new G4Element(name="Cesium", symbol="Cs", Z=55., A);

  A= 22.989768 *g/mole;
  G4Element* elNa= new G4Element(name="Sodium", symbol="Na", Z=11., A);

  // ==============================================================
  // materials
  // ==============================================================
  G4double density, massfraction;
  G4int natoms, nel;

  // temperature of experimental hall is controlled at 20 degree.
  const G4double expTemp= STP_Temperature+20.*kelvin;

  // vacuum
  density= universe_mean_density;
  G4Material* Vacuum= new G4Material(name="Vacuum", density, nel=2);
  Vacuum-> AddElement(elN, .7);
  Vacuum-> AddElement(elO, .3);


  // air
  density= 1.2929e-03 *g/cm3;  // at 20 degree
  G4Material* Air= new G4Material(name="Air", density, nel=3,
                                  kStateGas, expTemp);
  G4double ttt= 75.47+23.20+1.28;
  Air-> AddElement(elN,  massfraction= 75.47/ttt);
  Air-> AddElement(elO,  massfraction= 23.20/ttt);
  Air-> AddElement(elAr, massfraction=  1.28/ttt);


  //----------------Iron                                                        
  A = 55.85*g/mole;
  density = 7.87*g/cm3;
  G4Material* Fe = new G4Material(name="Iron", Z=26., A, density);

  //----------------Copper
  A = 63.546*g/mole;
  density = 8.96*g/cm3;
  G4Material* Cu = new G4Material(name="Copper", Z=29., A, density);

  //----------------Carbon
  A = 12.0107*g/mole;
  //  density = 2.265*g/cm3; //--> not diamond
  density = 3.53*g/cm3; //--> diamond in wiki
  G4Material* C = new G4Material(name="Carbon", Z=6., A, density);


  // Ar gas
  A= 39.948 *g/mole;
  const G4double denAr= 1.782e-03 *g/cm3 * STP_Temperature/expTemp;
  G4Material* Ar= new G4Material(name="ArgonGas", Z=18., A, denAr,
                                 kStateGas, expTemp);



  // ethane (C2H6)
  const G4double denEthane= 1.356e-3 *g/cm3 * STP_Temperature/expTemp;
  G4Material* Ethane= new G4Material(name="Ethane", denEthane, nel=2,
                                     kStateGas, expTemp); 
  Ethane-> AddElement(elC, natoms=2);
  Ethane-> AddElement(elH, natoms=6);

  // methane (CH4)
  const G4double denMethane= 0.717e-3 *g/cm3 * STP_Temperature/expTemp;
  G4Material* Methane= new G4Material(name="Methane", denMethane, nel=2,
                                     kStateGas, expTemp);
  Methane-> AddElement(elC, natoms=1);
  Methane-> AddElement(elH, natoms=4);

  // Ar(50%) + ethane(50%) mixture
  density=  (denAr+denEthane)/2.;
  G4Material* ArEthane= new G4Material(name="ArEthane", density, nel=2,
                                       kStateGas, expTemp);
  ArEthane-> AddMaterial(Ar, massfraction= denAr/2./density);
  ArEthane-> AddMaterial(Ethane, massfraction= denEthane/2./density);


  // P10 gas Ar(90%) + methane(10%) mixture
  density=  0.9*denAr+0.1*denMethane;
  G4Material* P10= new G4Material(name="P10", density, nel=2,
                                       kStateGas, expTemp);
  P10-> AddMaterial(Ar, massfraction= 0.9*denAr/density);
  P10-> AddMaterial(Methane, massfraction= 0.1*denMethane/density);

  // G10 epoxy glass
  G4int ncomponents;
  density = 1.700*g/cm3;
  G4Material* G10 = new G4Material(name="NemaG10", density, ncomponents=4);
  G10->AddElement(elSi, natoms=1);
  G10->AddElement(elO , natoms=2);
  G10->AddElement(elC , natoms=3);
  G10->AddElement(elH , natoms=3);

  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // scintillator (Polystyene(C6H5CH=CH2))
  // implement here
  density = 1.032 *g/cm3;
  G4Material* Scinti = new G4Material(name="Scinti", density, nel=2);
  Scinti->AddElement(elC,natoms=8);
  Scinti->AddElement(elH,natoms=8);

  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // CH2 Polyethelene
  // 
  density = 0.95 *g/cm3;
  G4Material* CH2 = new G4Material(name="CH2", density, nel=2);
  CH2->AddElement(elC,natoms=1);
  CH2->AddElement(elH,natoms=2);

  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  // quartz (SiO2, crystalline)
  density= 2.64 *g/cm3;
  G4Material* Quartz= new G4Material(name="Quartz", density, nel= 2);
  Quartz-> AddElement(elSi, natoms=1);
  Quartz-> AddElement(elO,  natoms=2);




  // ==============================================================
  // geometry
  // ==============================================================

  // ==============================================================
  // Experimental Hall (world)
  // ==============================================================
  const G4double R_EXPHALL=   3.0*m;
  const G4double DZ_EXPHALL=  10.0*m;

  G4Tubs* expHallSolid=
    new G4Tubs("EXP_HALL", 0., R_EXPHALL, DZ_EXPHALL, 0., 360.*deg);

  G4LogicalVolume* expHallLV=
    new G4LogicalVolume(expHallSolid, Air, "EXP_HALL_LV");

  // visualization attributes
  G4VisAttributes* expHallVisAtt=
    new G4VisAttributes(false, G4Colour(1., 1., 1.));
  expHallLV-> SetVisAttributes(expHallVisAtt);
  
  G4PVPlacement* expHall= new G4PVPlacement(0, G4ThreeVector(), "EXP_HALL_PV",
                                            expHallLV, 0, false, 0);

  // ==============================================================
  //  Time projection chamber
  // ==============================================================  

  // ==============================================================  
  // Frame
  // ==============================================================

  const G4double ROUT_TPC=  250.*mm;
  const G4double RIN_TPC=  0.0*mm;
  const G4double DZ_TPC=    300.*mm;
  const G4double DZ_TPC_OFFSET = 0.*mm;
  const G4double DPHI_TPC=  360.*deg;

  const G4double zz_o[2]={-DZ_TPC, DZ_TPC};
  const G4double r_in_o[2]={0.5*sqrt(3.0)*RIN_TPC, 0.5*sqrt(3.0)*RIN_TPC};
  const G4double r_out_o[2]={0.5*sqrt(3.0)*ROUT_TPC+50, 0.5*sqrt(3.0)*ROUT_TPC+50};

  G4Polyhedra* TPCSolid =
    new G4Polyhedra("TPCHedra",0.,DPHI_TPC,8,2,zz_o,r_in_o,r_out_o);
  //  G4Tubs* TPCSolid =
  //    new G4Tubs("TPCHedra",0.,ROUT_TPC,DZ_TPC,0.*deg,DPHI_TPC);
  G4LogicalVolume* TPCLV=
    new G4LogicalVolume(TPCSolid, P10, "TPC_LV");
  G4RotationMatrix *rotTPC = new G4RotationMatrix();
  rotTPC->rotateX(90.*deg);

  G4PVPlacement* TPCPV =
    new G4PVPlacement(rotTPC, G4ThreeVector(0,0,DZ_TPC_OFFSET),
		      "TPC_PV", TPCLV, expHall, FALSE, 1);
  G4VisAttributes* TPCVisAtt= new G4VisAttributes(true, G4Colour(1.,1.,1.));
  TPCLV-> SetVisAttributes(TPCVisAtt);

  
  // ==============================================================
  // Virtual pads
  // ==============================================================




  ///////////////////

  char name5[30];
  char name6[30];
  char name7[30];
  G4Tubs* padSolid[40];
  G4LogicalVolume* padLV[40];
  //  G4VPhysicalVolume* padPV[40];

  G4double angle[40];
  angle[10]=32.2793;
  angle[11]=44.6746;
  angle[12]=53.6790;
  angle[13]=60.940;
  angle[14]=67.1146;
  angle[15]=72.5423;
  angle[16]=77.429;
  angle[17]=81.909;
  angle[18]=86.076;
  angle[19]=90.00;
  angle[20]=93.7314;
  angle[21]=97.31;
  angle[22]=100.77;
  angle[23]=104.14;
  angle[24]=107.45;
  angle[25]=110.72;
  angle[26]=113.9;
  angle[27]=117.2;
  angle[28]=120.4;
  angle[29]=123.7;
  angle[30]=127.1;
  angle[31]=130.5;
  angle[32]=134.1;
  angle[33]=137.8;
  angle[34]=141.7;
  angle[35]=146.06;
  angle[36]=150.8;
  angle[37]=156.3;
  angle[38]=163.3;
  angle[39]=171.0;


  G4VisAttributes* padVisAtt= new G4VisAttributes(false, G4Colour(0.,0.,1.));
  //  G4cout<<"pad install"<<G4endl;
  G4PVPlacement* padPV[40];
  G4RotationMatrix *rotPad = new G4RotationMatrix();
  for(G4int i=0;i<9;i++ ){
    sprintf(name5, "padSolid[%d]", i);
    sprintf(name6, "PadLV%d", i);
    sprintf(name7, "PadPV%d", i);
    padSolid[i] = new G4Tubs("TPC pad", (1+i)*cm, (1.8+i)*cm,
			     250.*mm, 0., 360.*deg);
    padLV[i]  = new G4LogicalVolume(padSolid[i],P10,name6);
    padLV[i]-> SetVisAttributes(padVisAtt);

    padPV[i] =
      new G4PVPlacement(rotPad, G4ThreeVector(0.,150.*mm,0.*mm),padLV[i],name7,TPCLV, true, i+2);
  }

  G4RotationMatrix* rotpad = new G4RotationMatrix();
  G4ThreeVector padpos(0.,150.*mm,0.*mm);
  //  rotpad.rotateZ(-90.*deg);
  G4VisAttributes* padVisAtt1= new G4VisAttributes(false, G4Colour(1.,0.5,0.));
  for(G4int i=9;i<38;i++ ){
    sprintf(name5, "padSolid[%d]", i);
    sprintf(name6, "PadLV%d", i);
    sprintf(name7, "PadPV%d", i);
    padSolid[i] = new G4Tubs("TPC pad", (1+i)*cm, (1.8+i)*cm,
			     250.*mm,(90.+angle[i+1])*deg, (360.-2.*angle[i+1])*deg);
    padLV[i]  = new G4LogicalVolume(padSolid[i],P10,name6);
    padLV[i]-> SetVisAttributes(padVisAtt1);
    //    rotpad->rotateZ(-(30.+20*i)*deg);
    //    rotpad->rotateZ((-90+12*(i-8))*deg);
    //    padpos.rotateZ((5*(i-8))*deg);
    padPV[i] =
      new G4PVPlacement(rotPad, padpos, padLV[i],name7,TPCLV, true, i+2);
    //    rotpad->rotateZ((12*(i-8))*deg);
  }



  //////////////// virtual pad

  G4VisAttributes* padVVisAtt= new G4VisAttributes(true, G4Colour(0.,0.,1.));
  G4Tubs* padVSolid[40];
  G4LogicalVolume* padVLV[40];
  G4PVPlacement* padVPV[40];
  for(G4int i=0;i<9;i++ ){
    sprintf(name5, "padVSolid[%d]", i);
    sprintf(name6, "PadVLV%d", i);
    sprintf(name7, "PadVPV%d", i);
    padVSolid[i] = new G4Tubs("TPC pad", (1+i)*cm, (1.8+i)*cm,
			     0.5*mm, 0., 360.*deg);
    padVLV[i]  = new G4LogicalVolume(padVSolid[i],P10,name6);
    padVLV[i]-> SetVisAttributes(padVVisAtt);
    padVPV[i] =
      new G4PVPlacement(rotPad, G4ThreeVector(0.,150.*mm,-253.*mm),padVLV[i],name7,TPCLV, true, 0);
  }

  G4VisAttributes* padVVisAtt1= new G4VisAttributes(true, G4Colour(1.,0.5,0.));
  for(G4int i=9;i<38;i++ ){
    sprintf(name5, "padVSolid[%d]", i);
    sprintf(name6, "PadVLV%d", i);
    sprintf(name7, "PadVPV%d", i);
    padVSolid[i] = new G4Tubs("TPC pad", (1+i)*cm, (1.8+i)*cm,
			     0.5*mm,(90.+angle[i+1])*deg, (360.-2.*angle[i+1])*deg);
    padVLV[i]  = new G4LogicalVolume(padVSolid[i],P10,name6);
    padVLV[i]-> SetVisAttributes(padVVisAtt1);
    padVPV[i] =
      new G4PVPlacement(rotPad, G4ThreeVector(0.,150.*mm,-253.*mm), padVLV[i],name7,TPCLV, true, 0);
  }


  const int NUM_PAD = 40.;
  ///////////////////



  //  const double DX_PAD = 0.5*15.0*mm;
  const double DX_PAD = 0.5*10.0*0.5*mm;
  double DY_PAD = 0.5*5.7*0.5*mm;
  //  const double DZ_PAD = 376.0*mm;
  const double DZ_PAD = 250.0*mm;
  //  const double DZ_TPC_PAD_OFFSET = -97.0*0.5*mm;
  const double DZ_TPC_PAD_OFFSET = 0.*mm;

  const int NUM_LAY = 20;
  const int NUM_SECTOR = 6;
  //  const int NUM_PAD = NUM_LAY*NUM_SECTOR;

  const G4double padAngle = 60.0*deg;
  G4int ipad = 0;
  /*
  G4Box* padSolid[NUM_PAD];
  G4LogicalVolume* padLV[NUM_PAD];
  G4VPhysicalVolume* padPV[NUM_PAD];

  G4RotationMatrix* padRotM = new G4RotationMatrix;
  padRotM->rotateZ(padAngle*0.5);


  //  for(G4int i=0;i<9;i++){
  for(G4int i=0;i<NUM_LAY;i++){

    G4int irow = 0;

    for(G4int k=0;k<NUM_SECTOR;k++){

      sprintf(name1, "PadLV%dLay%dRow%d",ipad,i,irow);
      sprintf(name2, "PadPV%dLay%dRow%d",ipad,i,irow);

      DY_PAD = 0.5*5.7*(1.0+2.0*i)*mm;
      padSolid[ipad] = new G4Box("TPC Pad", DX_PAD, DY_PAD, DZ_PAD);
      padLV[ipad] = new G4LogicalVolume(padSolid[ipad], P10, name1);
      //      G4ThreeVector padPosM((6.13+0.75)*cm+i*15.0*mm,0.0,DZ_TPC_PAD_OFFSET);
      G4ThreeVector padPosM((0.75)*cm+i*10.0*mm,0.0,DZ_TPC_PAD_OFFSET);

      padPosM.rotateZ(padAngle*(0.5+k));
      G4Transform3D padTransformM(*padRotM, padPosM);

      padPV[ipad] = new G4PVPlacement(padTransformM, name2,
				      padLV[ipad], TPCPV, FALSE, ipad);
      G4VisAttributes* padVisAtt =
      	new G4VisAttributes(true, magenda);
      //      	new G4VisAttributes(false, magenda);

      padLV[ipad]-> SetVisAttributes(padVisAtt);
      ipad++;
      irow++;
      padRotM->rotateZ(padAngle);    

    }

  }
  */
  printf("%d pads are installed\n",ipad);

  // ==============================================================
  //  Target 
  // ==============================================================  


  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.25*cm,1.5*cm);
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.25*cm,1.5*cm);
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.5*cm,0.25*cm); // 30 x 10 x 5 
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.5*cm,0.5*cm); // 30 x 10 x 10 
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.5*cm,0.75*cm); // 30 x 10 x 15 
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.5*cm,1.00*cm); // 30 x 10 x 20 
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.5*cm,1.25*cm); // 30 x 10 x 25 
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.5*cm,1.5*cm); // 30 x 10 x 30 

  //ubove is wrong. x, z, y. is right.

  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.25*cm,0.5*cm); // 30 x 10 x 5 
  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.5*cm,0.5*cm); // 30 x 10 x 10 
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,0.75*cm,0.5*cm); // 30 x 10 x 15 
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,1.0*cm,0.5*cm); // 30 x 10 x 20 
  //  G4Box* TargetSolid = new G4Box("target", 1.5*cm,1.25*cm,0.5*cm); // 30 x 10 x 25 
  //    G4Box* TargetSolid = new G4Box("target", 1.5*cm,1.5*cm,0.5*cm); // 30 x 10 x 30 

  //  G4Box* TargetSolid = new G4Box("target", 1.*cm,0.25*cm,1.*cm);
  G4LogicalVolume* TargetLV=
    new G4LogicalVolume(TargetSolid, C, "TargetLV");
  G4PVPlacement* TargetPV =
    new G4PVPlacement(0, G4ThreeVector(0,150*mm,0.*mm),
                      TargetLV, "TargetPV",TPCLV, true, 1);
  G4VisAttributes* TargetVisAtt= new G4VisAttributes(true, G4Colour(1.,0.,0.));
  TargetLV-> SetVisAttributes(TargetVisAtt);



  // ==============================================================
  //  Solenoid Magnet
  // ==============================================================


  // ==============================================================
  // Scintillators
  // ==============================================================
  const G4int NPHI_SCINT = 16;

  G4LogicalVolume* scintLV[NPHI_SCINT];
  G4VPhysicalVolume* scintPV[NPHI_SCINT];
  G4VisAttributes* scintVisAtt[NPHI_SCINT];

  // ==============================================================
  // Side Scintillators (Outer)
  // ==============================================================
  //thickness 5mm
  //  const G4double R_SCINT =  ROUT_TPC*0.5*sqrt(3.0)+2.5*1.0;
  const G4double DX_SCINT1 = 2.5*mm;
  //  const G4double DY_SCINT = 72.5*mm;
  const G4double DZ_SCINT1 = (350.-2.5)*tan(22.5*deg)/2*mm;
  const G4double DY_SCINT1 = 500.0*mm;
  //  const G4double DZ_SCINT_OFFSET = -26.5*cm+42.5*cm;

  const G4double DX_SCINT2 = 2.5*mm;
  const G4double DZ_SCINT2 = (350.-2.5)*tan(22.5*deg)/2*mm;
  const G4double DY_SCINT2 = 500.0*mm;


  G4Box* scintSolid1= new G4Box("SIDE SCINT1", DX_SCINT1,
                                     DY_SCINT1,  DZ_SCINT1);
  G4Box* scintSolid2= new G4Box("SIDE SCINT2", DX_SCINT2,
                                     DY_SCINT2,  DZ_SCINT2);

  // 16 side scint.
  
  const G4double dangleOut = 22.5*2*deg;
  G4ThreeVector posMOut1(350.*mm,0.*mm,(-DZ_SCINT2)); //x,z,y??
  G4ThreeVector posMOut2(350.*mm,0.*mm,(+DZ_SCINT2)); //x,z,y??
  G4RotationMatrix* rotMOutP = new G4RotationMatrix;
  rotMOutP->rotateY(dangleOut*0.5);
  posMOut1.rotateY(dangleOut*0.5);
  posMOut2.rotateY(dangleOut*0.5);

  //  for(G4int k=0;k<NPHI_SCINT; k++){
  for(G4int k=0;k<8; k++){
    /*    if(k>=4){
      G4Transform3D transformMP(*rotMOutP, posMOut1);
    sprintf(name1, "ScintLV%d",k);
    sprintf(name2, "ScintPV%d",k);
    scintLV[k] = new G4LogicalVolume(scintSolid1, Scinti, name1);
    scintPV[k] = new G4PVPlacement(transformMP, name2, scintLV[k], expHall, FALSE, k);*/
    //    }
  //    if(k%2==0){
    G4Transform3D transformMP1(*rotMOutP, posMOut1);
    sprintf(name1, "ScintLV%d",k*2);
    sprintf(name2, "ScintPV%d",k*2);
    scintLV[k*2] = new G4LogicalVolume(scintSolid1, Scinti, name1);
    scintPV[k*2] = new G4PVPlacement(transformMP1, name2, scintLV[k*2], expHall, FALSE, k*2);

    G4Transform3D transformMP2(*rotMOutP, posMOut2);
    sprintf(name11, "ScintLV%d",k*2+1);
    sprintf(name22, "ScintPV%d",k*2+1);
    scintLV[k*2+1] = new G4LogicalVolume(scintSolid1, Scinti, name11);
    scintPV[k*2+1] = new G4PVPlacement(transformMP2, name22, scintLV[k*2], expHall, FALSE, k*2);


    scintVisAtt[k*2]= new G4VisAttributes(true, aqua);
    scintLV[k*2]-> SetVisAttributes(scintVisAtt[k*2]);
    scintVisAtt[k*2+1]= new G4VisAttributes(true, aqua);
    scintLV[k*2+1]-> SetVisAttributes(scintVisAtt[k*2+1]);

    rotMOutP->rotateY(dangleOut);
    posMOut1.rotateY(dangleOut); 
    posMOut2.rotateY(dangleOut); 
  }

  // ==============================================================
  // helmholtz coil
  // ==============================================================
  G4Tubs* HelmSolid =
    new G4Tubs("HelmSolid",40.*cm,50.*cm,5*cm,0.*deg,DPHI_TPC);
  G4LogicalVolume* HelmLV=
    new G4LogicalVolume(HelmSolid, Fe, "HelmLV");
  G4RotationMatrix *rotHelm = new G4RotationMatrix();
  rotHelm->rotateX(90.*deg);
  G4PVPlacement* HelmPV[2];
  HelmPV[0] =
    new G4PVPlacement(rotHelm, G4ThreeVector(0,+20.*cm,0),
		      "HelmPV", HelmLV, expHall, FALSE, 0);
  HelmPV[1] =
    new G4PVPlacement(rotHelm, G4ThreeVector(0,-20.*cm,0),
		      "HelmPV", HelmLV, expHall, FALSE, 0);
  G4VisAttributes* HelmVisAtt= new G4VisAttributes(true, G4Colour(1.,0.5,0));
  HelmLV-> SetVisAttributes(HelmVisAtt);

  /////// supporter (from bottom to helmholtz)
  G4Box* HelmSuSolid =
    new G4Box("HelmSuSolid",3.*cm,60.*cm,3*cm);
  G4LogicalVolume* HelmSuLV=
    new G4LogicalVolume(HelmSuSolid, Fe, "HelmSuLV");
  G4PVPlacement* HelmSuPV[2];
  HelmSuPV[0] =
    new G4PVPlacement(0, G4ThreeVector(31*cm,-85.*cm,31*cm),
		      "HelmSuPV", HelmSuLV, expHall, FALSE, 0);
  HelmSuPV[1] =
    new G4PVPlacement(0, G4ThreeVector(-31*cm,-85.*cm,31*cm),
		      "HelmSuPV", HelmSuLV, expHall, FALSE, 0);
  HelmSuPV[2] =
    new G4PVPlacement(0, G4ThreeVector(-31*cm,-85.*cm,-31*cm),
		      "HelmSuPV", HelmSuLV, expHall, FALSE, 0);
  HelmSuPV[3] =
    new G4PVPlacement(0, G4ThreeVector(31*cm,-85.*cm,-31*cm),
		      "HelmSuPV", HelmSuLV, expHall, FALSE, 0);
  G4VisAttributes* HelmSuVisAtt= new G4VisAttributes(true, G4Colour(0.,0.0,1.));
  HelmSuLV-> SetVisAttributes(HelmSuVisAtt);

  /////// supporter (Between helmholtz coils)
  G4Box* HelmSuBeSolid =
    new G4Box("HelmSu1Solid",1.*cm,15.*cm,1*cm);
  G4LogicalVolume* HelmSuBeLV=
    new G4LogicalVolume(HelmSuBeSolid, Fe, "HelmSuBeLV");
  G4PVPlacement* HelmSuBePV[2];
  HelmSuBePV[0] =
    new G4PVPlacement(0, G4ThreeVector(31*cm,0.*cm,31*cm),
		      "HelmSuBePV", HelmSuBeLV, expHall, FALSE, 0);
  HelmSuBePV[1] =
    new G4PVPlacement(0, G4ThreeVector(-31*cm,0.*cm,31*cm),
		      "HelmSuBePV", HelmSuBeLV, expHall, FALSE, 0);
  HelmSuBePV[2] =
    new G4PVPlacement(0, G4ThreeVector(-31*cm,0.*cm,-31*cm),
		      "HelmSuBePV", HelmSuBeLV, expHall, FALSE, 0);
  HelmSuBePV[3] =
    new G4PVPlacement(0, G4ThreeVector(31*cm,0.*cm,-31*cm),
		      "HelmSuBePV", HelmSuBeLV, expHall, FALSE, 0);
  G4VisAttributes* HelmSuBeVisAtt= new G4VisAttributes(true, G4Colour(0.,0.0,1.));
  HelmSuBeLV-> SetVisAttributes(HelmSuBeVisAtt);






  // ==============================================================
  // ==============================================================
  // spectrometrr --> consist with kurama, SC, DC  
  // ==============================================================
  // ==============================================================

  //  G4double rotAngSP=15*deg;
  G4double rotAngSP=10*deg;
  G4RotationMatrix *rotSP=new G4RotationMatrix();
  rotSP->rotateY(-rotAngSP);
  
  // ==============================================================
  // SC , before guide
  // ==============================================================
  G4Box* SCSolid =
    new G4Box("SCSolid",200.*mm,50.*mm,5*mm); // position x - 150, y+ 300?? , z 820+kurama-z length
  G4LogicalVolume* SCLV=
    new G4LogicalVolume(SCSolid, Scinti, "SCLV");
  G4PVPlacement* SCPV[3];
  SCPV[0]=
    new G4PVPlacement(rotSP, G4ThreeVector(0.*cm,+100*mm,720*mm).rotateY(rotAngSP),
		      "SCPV", SCLV, expHall, FALSE, 0);
  SCPV[1]=
    new G4PVPlacement(rotSP, G4ThreeVector(0.*cm,0*mm,720*mm).rotateY(rotAngSP),
		      "SCPV", SCLV, expHall, FALSE, 0);
  SCPV[2]=
    new G4PVPlacement(rotSP, G4ThreeVector(0.*cm,-100*mm,720*mm).rotateY(rotAngSP),
		      "SCPV", SCLV, expHall, FALSE, 0);
  G4VisAttributes* SCVisAtt= new G4VisAttributes(true, aqua);
  SCLV-> SetVisAttributes(SCVisAtt);


  // ==============================================================
  // guide of Kurama 
  // ==============================================================
  G4Box* KuramaUDSolid =
    new G4Box("KuramaUDSolid",950.*mm,300.*mm,50*mm); // position x - 150, y+ 310?? , z 820+kurama-z length
  G4LogicalVolume* KuramaUDLV=
    new G4LogicalVolume(KuramaUDSolid, Fe, "KuramaUDLV");
  G4PVPlacement* KuramaUDPV[2];
  KuramaUDPV[0] =
    new G4PVPlacement(rotSP, G4ThreeVector(0.*cm,(300+200.)*mm,820*mm).rotateY(rotAngSP),
		      "KuramaUDPV", KuramaUDLV, expHall, FALSE, 0);
  KuramaUDPV[1] =
    new G4PVPlacement(rotSP, G4ThreeVector(0.*cm,(-300-200.)*mm,820*mm).rotateY(rotAngSP),
		      "KuramaUDPV", KuramaUDLV, expHall, FALSE, 0);
  G4VisAttributes* KuramaUDVisAtt= new G4VisAttributes(true, G4Colour(0.,0.0,1.));
  KuramaUDLV-> SetVisAttributes(KuramaUDVisAtt);

  G4Box* KuramaSiSolid =
    new G4Box("KuramaSiSolid",300.*mm,200.*mm,50*mm); // position x - 150, y+ 310?? , z 820+kurama-z length
  G4LogicalVolume* KuramaSiLV=
    new G4LogicalVolume(KuramaSiSolid, Fe, "KuramaSiLV");
  G4PVPlacement* KuramaSiPV[2];
  KuramaSiPV[0] =
    new G4PVPlacement(rotSP, G4ThreeVector(650.*mm,0.*mm,820*mm).rotateY(rotAngSP),
		      "KuramaSiPV", KuramaSiLV, expHall, FALSE, 0);
  KuramaSiPV[1] =
    new G4PVPlacement(rotSP, G4ThreeVector(-650.*mm,0.*mm,820*mm).rotateY(rotAngSP),
		      "KuramaSiPV", KuramaSiLV, expHall, FALSE, 0);
  G4VisAttributes* KuramaSiVisAtt= new G4VisAttributes(true, G4Colour(0.,0.0,1.));
  KuramaSiLV-> SetVisAttributes(KuramaSiVisAtt);


  // ==============================================================
  // Kurama --> consisted 4 blocks up, down, and two side blocks
  // ==============================================================




  // ==============================================================
  // mangentic field
  // ==============================================================
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
  // implement here

  TPCField* myfield = new TPCField("parameter/solenoid.dat");
  G4FieldManager* fieldMgr =
    G4TransportationManager::GetTransportationManager()->GetFieldManager();
  fieldMgr->SetDetectorField(myfield);
  fieldMgr->CreateChordFinder(myfield);
  G4cout << "test shhwang" << G4endl;
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  


  // ==============================================================
  // define detector sensitivity 
  // ==============================================================
  // sensitive Detectors

  G4SDManager* SDman= G4SDManager::GetSDMpointer();
  G4String SDname;
  //  G4cout << "test shhwang1" << G4endl;
  // ==============================================================
  // TPC Pad
  // ==============================================================

  TPCPadSD* padSD= new TPCPadSD(SDname="/TPC");
  SDman-> AddNewDetector(padSD);
  //  for(G4int i = 0;i<NUM_PAD;i++){
  for(G4int i = 0;i<38;i++){
    padLV[i]->SetSensitiveDetector(padSD);
  }
  TPCLV->SetSensitiveDetector(padSD);
  TargetLV->SetSensitiveDetector(padSD);

  //  G4cout << "test shhwang2" << G4endl;
  // ==============================================================
  // TPC scintillator (16 side + 2 downstream)
  // ==============================================================

  TPCScintSD* scintSD= new TPCScintSD(SDname="/SCINT");
  SDman-> AddNewDetector(scintSD);
  for(G4int i = 0; i<16; i++){
    scintLV[i]->SetSensitiveDetector(scintSD);
  }

  //    G4cout << "test shhwang3" << G4endl;
  // ==============================================================
  // FDC
  // ==============================================================


  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
  // ==============================================================
  // finally return the world volume
  // ==============================================================

  return expHall;

}
